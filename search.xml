<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[人在囧途]]></title>
    <url>%2F2018%2F08%2F06%2F%E4%BA%BA%E5%9C%A8%E5%9B%A7%E9%80%94%2F</url>
    <content type="text"><![CDATA[高铁逃票 ​ 从北京坐车回四川德阳，因买票较晚，就从西安转车，北京到西安z43次。西安北到成都东，终点站前一站下车。此为背景。 ​ z43车次应该是9:50到西安，下一班转车西安北站11:40,因为从西安站到西安北站有些距离，中途我预留了将近两小时转车。原计划不慌不忙地在西安换乘。在z43早7:00左右，车上通知晚点半小时，行吧，晚点就晚点，幸好预留转车时间还比较充裕。然后又通知晚点一小时，我。。。过分了啊。(这趟车从北京发出，到西安中途就停两个站，这还晚点一小时，你这是搞事情啊) ​ 之后的流程，那时候还没有慌张，按照火车规则（划重点了啊），下车后找列车长开证明，到车站，然后改签其它车次，若没有其它车次改签的，可全价退票。 ​ 列车到站时间10:55分，我找到列车长，列车长说误车的人很多，等都过来齐了一起办理。顺便问我下一班什么时间的，我拿出车票，然后她一脸着急：你快去西安北站，试着追一把这趟车，我们这是西安站，西安站开的证明西安北站不认。 oh no,要不要这么搞事情。 然后迅速拉着行李出站，边走边计划了最快路线：出站打车，到最近地铁站，然后地铁直奔北客站，对，就是要这么果断。 ​ naive，出站才发现，出租车巨多，只有一个固定的地方停靠出租车上下客，辣么长的队伍，起码也得排20分钟，此刻就剩下40几分钟，来不及了。拉着箱子再往地铁站方向走吧，去那条路上打车。刚想过马路，看到好多空的出租车缓慢行驶（这里不让上下客）,望了一眼最近的出租车，司机也看到我了，对，就是你了，司机在车里向我挥手，意思让快点过来。我迅速溜上车，司机刚要起步，窜出交警一枚，走到车面前，让司机拿驾照，让我下车。我。。。。。行吧，对不起你了司机师傅，我真有事，先走一步了。迅速溜走。 ​ 下车后拉着箱子急匆匆往前，有个人一直跟着我跑，边走边问，到西安北站走不走，30分钟给你送到，地铁站5分钟送到。黑车司机无疑了，不过我已经有点心动了，一番简单砍价，20块钱给我10分钟送到安远门地铁站，虽有还是有点小贵，不管啦，冲刺回去的高铁要紧。带着我急急忙忙到他停车的地方，what!!!!!,华丽丽一辆电动车，电动车，动车，车。。。行吧，无所谓啦，我忍了，赶紧的吧。就这么一路冲刺，到地铁站，换地铁，直达北客站，安检进站，一路暴走跑到检票口，11:37。已停止检票！已停止，停止，止。再给我多几分钟，哪怕3分钟。。。 然后拖着失望的心情，去了售票处。(敲黑板，接着划重点：高铁和动车的车票可以在开车后2小时之内改签一次 ) 绝望的是，售票员和我说：今天到四川的所有票都没有了。对，所有车次，包括站牌。。。。就在我正想着要不混上一趟回去的车时。售票员还是比较好心，帮我把没上车的票退了，然后说有一张到洋县西的高铁（陕西汉中的一个县），要过成都，要吗，坐到洋县西后和列车长商量补票，但是超员了就得下车了。要！我几乎不假思索。 ​ 拿到车票后，我开始打起了小算盘：1.按照售票员的说法，坐到洋县西，和列车长商量补票，然后回去，做一个安纪守法的良好青年。将要面临的风险是：列车满员，我被要求下车，滞留在一个小县城。2.不找列车员这些，先不管是否满员，坐到目的地之后，再说补票的事。将要面临的风险：高铁列车上检票不严，但是偶尔会查无座票和对应座位号的学生票，要是被查出逃票，我将受到罚款和随时被要求下车的处罚。多次考虑下，我选择了后者，因为我现在最重要的事情是回到家，能不能被查出逃票，就要看演技和观察力了。 ​ 上车检票时刻，我的左列排了30多个学生，高中生样子，一律拿着红色车票，应该是参加夏令营什么的。一个老师模样的男子背着书包，上书几个汉字“四川什邡，山水之乡”（什邡是德阳下属的县级市）。我立马知道，这帮孩子肯定在德阳站下车，我想他们这么多人，我想应该会对我有用。接下来上车，坐到洋县西，我起身让开座位，然后开始拿着充电器，到水池旁一个插座旁充电玩手机，假装我是个有座的人，只是来这儿充下电，（据我了解，高铁列车员查票很随机，重点查无座人员的）。一边打发心里的紧张，一边观察者列车员的动向。最惊险的一次，是一个列车员那这个小本本站在了我前面不远，再和其它站票的人说着什么，我立马从发呆中惊醒，拿着手上的水杯，假装去接水，跟正面过来的列车员插肩而过，非常自然的表情，对，一定要自然，镇定。接下来问题又来了，要是如愿到站后，怎么出站。出站口或者快到站补票，不过了解了一下，过站的区间，在原票价上，加收50%罚款。。。贫穷使我后退，迅速打开12306，找了张成都到德阳的车票，和现在坐的车同一时间到站的另一趟车，花了十几块钱，预定了，做个两手准备，不能出站，让我补票，我就说票不小心丢了，可以查票的记录，买的是成都到德阳的。嗯，就这么干。 ​ 所幸一路没人过问，两小时提心吊胆加暗中观察，终于到站。下车慢慢走着，看着人走在前面，我拿出车票，一手拎着箱子，一手拿起手机假装正在打电话，然后手指夹着车票，只露出车次，盖住到站名。正好看见了那帮学生出站，还拿着红色车票，走人工通道，机会啊，混在他们中间，查票员看了前面几个人，发现一帮学生，都一样，摆摆手，不一个一个看了，赶紧过。我装装样子晃一晃车票，yes,顺利出站。 ​ ps:逃票不可取，不到万不得已，不可效仿！ ​ ​]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程和进程的区别]]></title>
    <url>%2F2018%2F07%2F25%2F%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[一篇文章说清楚java线程的使用]]></title>
    <url>%2F2018%2F07%2F25%2Fjava%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录大纲： java线程的两种创建方式和启动 线程的优先级别 线程的各种状态 守护线程（Daemon）的概念和使用 线程中断和终止 线程的通信 创建java线程的两种方式和启动 继承Thread类 继承Thread类，然后重写run()方法，通过线程的start()开启线程 1234567891011121314public class RunByThread extends Thread&#123; @Override public void run()&#123; while(true)&#123; try&#123; Thread.sleep(5000); System.out.println("running by thread......"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现Runnable接口 与Thread类似，实现Runnable接口，重写其中的run()方法，通过线程的start()开启线程。 1234567891011121314151617public class RunByRunnable implements Runnable &#123; public void run() &#123; while(true)&#123; try&#123; Thread.sleep(1000); System.out.println("running by runnable......"); &#125;catch (InterruptedException e)&#123; System.out.println("interrupted..."); e.printStackTrace(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.启动线程 ​ 继承Thread类的子类，可通过[1.创建新对象]或者[2.创建对象放入Thread类]来创建线程 ​ 实现Runnable接口的方法，通过新建对象，放入Thread类中来创建线程。因为Runnable接口只有run()方法。 ​ 使用Thread提供的start()方法启动线程 1234567891011121314151617public class StartThead &#123; public static void main(String[] args) &#123; //继承Thread类的方法，可以通过以下两种方法开启线程 //1. 创建实例 RunByThread runByThread = new RunByThread(); runByThread.start(); //2. 创建对象，放入Thread中 Thread threadRun = new Thread(new RunByThread()); threadRun.start(); threadRun.isInterrupted(); //实现Runnable接口的方法，通过以下一种方法开启线程。 //创建对象，放入Thread中 Thread thread = new Thread(new RunByRunnable(),"runByThread"); thread.start(); &#125;&#125; 线程的优先级别现代操作系统基本采⽤时分的形式调度运⾏的线程，操作系统会分出⼀个个时间⽚，线程会分配到若⼲时间⽚，当线程的时间⽚⽤完了就会发⽣线程调度，并等待着下次分配。 设置线程的优先级，目的是按照线程优先级给线程分配时间片的多少，优先级越高，时间片越多。 优先级范围： 1-10 方法 setPriority(int) 代码实例： 1234567891011121314151617181920212223242526public class RunByRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; RunByRunnable runByRunnable = new RunByRunnable(); Thread thread1 = new Thread(runByRunnable,"run1"); Thread thread2 = new Thread(runByRunnable,"run2"); Thread thread3 = new Thread(runByRunnable,"run3"); Thread thread4 = new Thread(runByRunnable,"run4"); thread1.setPriority(5); thread2.setPriority(3); thread3.setPriority(8); thread4.setPriority(1); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125; (敲黑板！！)在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚⾄会忽略对线程优先级的设定。so: ==线程优先级不能作为程序正确性的依赖== 线程的状态java线程中一共有6种状态： new 新创建状态，还未调用start()方法 runnable 运行状态，java中，将就绪和运行统称“运行中” blocked 阻塞状态，线程阻塞于锁 waiting 等待状态，一直等待通知或中断 time_waiting 超时等待，等待通知或中断，超时后自动返回 terminated 当前线程已经执行完毕]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2F2018%2F07%2F16%2Fsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[定义synchronized方法是java中常用的关键字，属于JVM层面，java的内置锁,Java中的每一个对象都可以作为锁，当对象被synchronized锁住之后，此对象当前是被该锁和该线程独占。 应用分为修饰方法和修饰代码块两大类：具体如下 4种用法： 修饰实例方法 修饰静态方法 同步实例方法中的代码块 同步静态方法中的代码块 修饰实例方法123456789public synchronized void addOne()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; num++; System.out.println(this.getId()+" "+num+" "+System.currentTimeMillis()); &#125; 当修饰实例方法时，锁住的是调用该方法的当前对象，即：12Thread thread1 = new ThreadTest();Thread thread2 = new ThreadTest(); thread1和thread2在同一时刻调用是不会产生冲突的，但是thread1和thread2自身内部是会相互竞争的。例，多个线程不能同时调用thread1.addOne()方法。 修饰静态方法123456789public static synchronized void addTwo()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; count += 2; System.out.println(" "+count+" "+System.currentTimeMillis()); &#125; 锁住的是当前这个类的Class对象，即：当调动 addTwo()方法时，将产生竞争。不论实例对象是什么 修饰实例方法中的代码块1234567891011121314public void addThree()&#123; //使用了“this”，即为调用add方法的实例本身。 synchronized (this)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; number += 3; &#125; System.out.println(" "+number+" "+System.currentTimeMillis()); &#125; 重点关注synchronized (this)括号里面。this指定是引用的当前对象，效果和修饰实例方法一致。当()里面是 当前类的class对象时SynchronizedTest.class，效果和修饰静态方法一致。 修饰静态方法中的代码块123456789101112public static void addFour()&#123; synchronized (SynchronizedTest.class)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; counter += 4; &#125; System.out.println(" "+counter+" "+System.currentTimeMillis()); &#125; 当静态方法时，()里面只能是当前类的class对象 SynchronizedTest.class，效果和修饰静态方法一致。 原理附录，完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import lombok.Data;/** * @author xiaoran * @version 1.0 * * * 1.修饰实例方法 * 2.修饰静态方法 * 3.同步实例方法中的代码块 * 4.同步静态方法中的代码块 */@Datapublic class SynchronizedTest extends Thread&#123; private Integer num = 100; private static Integer count = 200; private Integer number = 300; private static Integer counter = 400; public synchronized void addOne()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; num++; System.out.println(this.getId()+" "+num+" "+System.currentTimeMillis()); &#125; public static synchronized void addTwo()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; count += 2; System.out.println(" "+count+" "+System.currentTimeMillis()); &#125; public void addThree()&#123; //使用了“this”，即为调用add方法的实例本身。 synchronized (this)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; number += 3; &#125; System.out.println(" "+number+" "+System.currentTimeMillis()); &#125; public static void addFour()&#123; synchronized (SynchronizedTest.class)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; counter += 4; &#125; System.out.println(" "+counter+" "+System.currentTimeMillis()); &#125; public void run()&#123; addOne(); addTwo(); addThree(); addFour(); &#125; public static void main(String[] args) &#123; SynchronizedTest thread1 = new SynchronizedTest(); SynchronizedTest thread2 = new SynchronizedTest(); SynchronizedTest thread3 = new SynchronizedTest(); SynchronizedTest thread4 = new SynchronizedTest(); SynchronizedTest thread5 = new SynchronizedTest(); SynchronizedTest thread6 = new SynchronizedTest(); thread1.start(); thread2.start(); thread3.start(); thread4.start(); thread5.start(); thread6.start(); &#125;&#125;]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁和悲观锁]]></title>
    <url>%2F2018%2F07%2F12%2F%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[这两个属于常在数据库事务中被提及，乐观锁和悲观锁属于思想级别，是为了保持事务的隔离性以及数据库的一致性而被业内定义出来的一种手段,并不属于数据库锁机制,但是悲观锁是依赖于数据库的锁机制实现的。乐观锁不是数据库自带的，需要自己去实现。 定义 乐观锁：当前事务操作数据时，认为其他事务不会修改正在读取的数据具体： 事务读取 ，不上锁 事务更新，在提交数据更新之前，先检查在该事务读取数据后（更新前），有没有其他事务又修改了该数据。无，则事务提交；有，则事务失败。 悲观锁：认为事务在操作数据的时候，肯定会出现冲突数据库中悲观锁的实现分两种： 共享锁 （读锁，针对select的锁机制）读：多个事务可叠加锁，可以读数据，写数据将等待所有读锁都释放才能执行当对一个数据加入共享锁，其他事务对该数据最多只能再加共享锁，不能加排它锁 排它锁 （写锁，针对update,delete的锁机制）写：写数据时，独占该数据，该数据不能再加入任何其他锁，也不能叠加排它锁 怎么使用乐观锁和悲观锁是一种思想，在java中和数据库中均有不同的思路实现 java实现12* 乐观锁 java.util.concurrent.atomic包中的类，通过CAS算法实现* 悲观锁 sychronized方法 数据库实现1* 乐观锁 自行实现，可通过版本号或者时间戳实现 例子：下单操作 1. 查询当前信息，包括版本号 `select (status,status,version) from t_goods where id=#{id}` 2. 生成订单，业务操作 3. 更新数据 `update t_goods set status = #{status},version=version+1 where id=#{id} and version=#{version}` 123* 悲观锁 * 共享锁实现 sql语句： `lock in share mode` 例子：开启三个终端，非自动提交事务模式 一个终端开启共享锁 ​ 另一个终端对数据进行读，读成功，叠加共享锁也可以 第三个终端对数据进行update操作，写失败，一直等待 12* 排它锁实现 sql语句：`for update` 例子：开启两个终端 第一个执行排它锁，暂不提交事务 第二个终端执行两个操作select: 查询出未更改前的数据update:等待，如下图 当第一个终端提交事务 commit work,第二个终端的update操作执行完成 优缺点 乐观锁： 优点：适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 缺点，冲突比较多的情况，执行会存在大量的失败，上层应用会不断的retry，这样反倒是降低了性能 悲观锁： 优点：保证了数据的完整性 缺点： 处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试真题]]></title>
    <url>%2F2018%2F07%2F10%2F%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[考拉阅读笔试题 基础部分，数组的传递是传递对象还是复制对象 补码计算方式 synchronized方法可修饰的是什么，修饰时候的作用是什么 写线程 面试题 hashmap和cocurrentHashMap的区别和联系 volatile方法的作用和内部分析 redis分布式锁 数据库中的锁 cas 还需准备的地方 redis的数据类型 并发 rabbitmq的复习 kafka的概念 spring boot redis 猫眼电影​ 先看简历，根据简历发问 画一画项目的系统架构图，使用的技术栈 mycat底层怎么管理主从，怎么管理读写分离 设计一个发报器的方案，用来生成id，不重复 ***（随意设计方案，分布式环境下） rabbitmq和kafka的选型（技术方案对比），底层的原理是否了解 dubbo,RPC的调用方式和HTTP调用方式的区别 java基础 hashmap的结构是什么样的，线程安全吗 hashMap中的红黑树，时间复杂度是多少，是否有安全的集合 concurrentHashMap的结构是什么样子的 为什么concurrentHashMap是安全的 volatile方法的作用是什么 volatile底层原理是什么，怎么实现的 java的内存屏障对volatile的影响 lock和sychronized是否了解，简述下区别 线程池是否了解，线程池在创建的时候，必传的参数是哪些 写一段代码，二分查找，时间复杂度多少 快看漫画 log日志是否会影响性能 rabbitmq和kafka选型区别 rabbitmq数据存储的地方 算法：将一个有序的短数组，插入到有序的长数组中，要求保证长数组有序 瓜子二手车 项目结构图 kafka和rabbitmq选型 技术对比 项目数据库怎么使用的 数据库事务机制分类 幻读和脏读 数据库索引分类 数据库主从通过什么实现的 索引分类 spring 和spring boot的关系 spring IOC怎么理解 IOC的注入方式分类 spring AOP怎么理解 aop通知的分类 环绕切点的使用 hashmap和hashtable的区别 concurrentHashMap volalite的作用 排序的map有哪些 sychronized锁对象 jvm的gc 线程池的种类 线程池的必要参数 遇到过最多的异常，异常的一些类 查找算法有哪些 二分查找的时间复杂度 排序算法有哪些 冒泡排序的时间复杂度 快排的时间复杂度 写一个算法：有一个数组，存在三种情况：1.递增 2.递减 3.先减后增（只有一个波谷）,写算法找出最小的值 花生好车 排序算法有哪些 设计不重复的分布式数据库id生成方案，按照一致性hash的思路怎么做 优化的思路，关于索引命中检查如何检查（索引的知识） 关于日志，是否真的有必要 数据库索引的B+树结构是否了解。in的操作是否会使用B+树 rabbitmq是否是有序的，有没有回应机制 rabbitmq的patition是否知道 redis的数据结构有几种 有一个对象，里面含有一些元素，怎么存入redis中（比较频繁操作，要求性能） redis的分布式集群怎么做 redis的持久化怎么实现 spring IOC容器注入原理，源码是否看过 java基础。集合的分类，collection下面有什么集合，map集合是不是在一起 map的初始容量和负载因子是多少 扩容怎么扩容，具体流程，是否是一个一个复制 concurrent包下面比较熟悉哪个知识点（volatile）,作用和原理是什么，应用场景是什么 队列同步器，是否熟悉，有哪些队列同步器 jvm中，堆和栈怎么定义，怎么使用 用java写一个链表的简单操作，插入一个元素和删除一个元素。 借贷宝 项目结构图 数据库索引，数据库索引命中怎么看（explain） 数据库索引怎么创建 数据库索引原理 数据库索引唯一索引怎么定义 身份证为例子 数据库联合索引 abc a ab abc 实现原理 sql语句调优怎么调优 乐观锁和悲观锁怎么定义，优缺点是什么 集合有哪些（学一下怎么描述） list和set的区别是什么 有一个list,里面有20个user,要求按照age存储，怎么存储 数据库中存储，按照class和sex统计总人数 group by git的工作区，暂存区和远程仓库 有两段代码重复，按照阿里规约怎么写 二叉树，层序遍历写出 引申： 数据库索引和原理一定要搞清楚（弱项） 二叉树几个遍历 java集合再总结一遍 突出亮点，让人感觉有特点]]></content>
  </entry>
</search>
