<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java线程通信]]></title>
    <url>%2F2018%2F08%2F26%2Fjava%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[[TOC] 这是Java线程技术的第二篇，主要讲解java线程之间的通信和交互. 第一篇详见 Java线程基础 等待通知 wait notify​ 想要实现一个这样的需求：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作。类似于消费者和生产者的概念，只是对象是两个线程。这时候，简单的操作，是另一个线程一直不断的循环监听一个变量，当变量如果进行改变，再进行相应的操作。但是如果采用这种做法，会存在两个比较明显的问题：1.开销过大，监听线程不断进行刷新判断，但是基本上都是无效的“尝试”，为了防止过快刷新，可采用睡眠的方式，但又导致了第二个问题；2，难以确保及时性，在睡眠是，基本上不消耗性能，但是睡眠期间，难以及时的发现条件已经修改。 ​ Java为我们提供了 wait/notify方法，很优雅的解决了这个问题。指的是，⼀个线程A调⽤了对象O的wait()⽅法进⼊ 等待状态，⽽另⼀个线程B调⽤了对象O的notify()或者notifyAll()⽅ 法，线程A收到通知后从对象O的wait()⽅法返回，进⽽执⾏后续操作。上述两个线程通过对象O来完成交互，⽽对象上的wait()和 notify()/notifyAll()的关系就如同开关信号⼀样，⽤来完成等待⽅和通 知⽅之间的交互⼯作。 ​ wait(),notify()和notifyAll()的方法均是Object类的内置方法，任何的Java对象均具有这些方法。 ​ 有两个细节需要注意： wait和notify必须配合synchronized使用 wait方法释放锁，但是notify方法不释放锁 经典模型 等待方 先执行 获取对象的锁 条件不满足，wait(),被通知后仍然检查条件 条件满足执行之后的逻辑 123456sychronized(lock)&#123; while(条件不满足)&#123; lock.wait(); &#125; 后续处理逻辑&#125; 通知方 后执行 获取对象的锁 改变条件 通知等待在对象上的线程 notifyAll() 12345sychronized(lock)&#123; xxx执行自己的逻辑 改变条件 lock.notifyAll()&#125; 实例代码 等待方： 123456789101112131415161718192021class Wait implements Runnable &#123; @Override public void run() &#123; //flag为false时，执行任务 synchronized (lock) &#123; while (flag) &#123; try &#123; System.out.println(Thread.currentThread() + "flag is true,wait:" + new SimpleDateFormat("HH:mm:ss").format(new Date())); //释放锁 lock.wait(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; //flag变为false System.out.println(Thread.currentThread() + "任务完成flag is false,wait:" + new SimpleDateFormat("HH:mm:ss").format(new Date())); &#125; &#125; &#125; 通知方： 1234567891011121314151617181920class Notify implements Runnable &#123; @Override public void run() &#123; synchronized (lock) &#123; //flag变为false System.out.println(Thread.currentThread() + " " + new SimpleDateFormat("HH:mm:ss").format(new Date())); flag = false; lock.notifyAll(); try &#123; TimeUnit.SECONDS.sleep(5); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("123"); &#125; &#125; 状态分析 1.wait方法调用后，线程装填由Running变为waiting状态，等待状态也是一个等待队列，先进入等待队列的，notify()先出队列 2.notify()或者notifyAll()方法调用后，等待线程不会立即从wait()中返回，需要获得锁之后才会返回。 3.notify()，将等待线程中的一个线程移动到同步队列，waiting状态变为BLOCKED，notifyAll()方法调用后，将等待的所有线程均移动到同步队列，由waiting状态变为BLOCKED 线层之间的IO 多个线程之间协作运行，势必会存在一些数据的交互，我们以需求为导向，当出现这种的需求，我们实现的方式是什么呢。 第一想到的是，共享变量。设置一个共享的变量，数据可以存在里面，使用volatile修饰，这个变量就可以在多个线程中保持可见。 这是一种办法。但是如果有10个线程，但是只能在A，B两个线程之间访问这个变量，其他变量不能访问，那么这样又该怎么做呢。 这时候可以通过java线程提供的IO操作来实现。管道输入/输出流。 线程之间的管道输⼊/输出流和普通的⽂件输⼊/输出流或者⽹络输⼊/输出流不同之处在于，它主要⽤于线程之间的数据传输，⽽传输的媒介为内存。 分类： 面向字节 PipedOutputStream PipedInputStream 面向字符 PipedReader PipedWriter 待续…]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一篇文章说清楚java线程-基础]]></title>
    <url>%2F2018%2F07%2F25%2Fjava%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[[TOC] 又骗到一个访问量。。。呸 ，java线程那么多知识，怎么可能一篇小文讲得完（或许大神能讲清楚）。脚踏实地，一步一步循序渐进才是最快的办法。对，我是说给自己这个急性子的😱 创建java线程的两种方式和启动 继承Thread类 继承Thread类，然后重写run()方法，通过线程的start()开启线程 1234567891011121314public class RunByThread extends Thread&#123; @Override public void run()&#123; while(true)&#123; try&#123; Thread.sleep(5000); System.out.println("running by thread......"); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 实现Runnable接口 与Thread类似，实现Runnable接口，重写其中的run()方法，通过线程的start()开启线程。 1234567891011121314151617public class RunByRunnable implements Runnable &#123; public void run() &#123; while(true)&#123; try&#123; Thread.sleep(1000); System.out.println("running by runnable......"); &#125;catch (InterruptedException e)&#123; System.out.println("interrupted..."); e.printStackTrace(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3.启动线程 ​ 继承Thread类的子类，可通过[1.创建新对象]或者[2.创建对象放入Thread类]来创建线程 ​ 实现Runnable接口的方法，通过新建对象，放入Thread类中来创建线程。因为Runnable接口只有run()方法。 ​ 使用Thread提供的start()方法启动线程 1234567891011121314151617public class StartThead &#123; public static void main(String[] args) &#123; //继承Thread类的方法，可以通过以下两种方法开启线程 //1. 创建实例 RunByThread runByThread = new RunByThread(); runByThread.start(); //2. 创建对象，放入Thread中 Thread threadRun = new Thread(new RunByThread()); threadRun.start(); threadRun.isInterrupted(); //实现Runnable接口的方法，通过以下一种方法开启线程。 //创建对象，放入Thread中 Thread thread = new Thread(new RunByRunnable(),"runByThread"); thread.start(); &#125;&#125; 线程的优先级别现代操作系统基本采⽤时分的形式调度运⾏的线程，操作系统会分出⼀个个时间⽚，线程会分配到若⼲时间⽚，当线程的时间⽚⽤完了就会发⽣线程调度，并等待着下次分配。 设置线程的优先级，目的是按照线程优先级给线程分配时间片的多少，优先级越高，时间片越多。 优先级范围： 1-10 方法 setPriority(int) 代码实例： 1234567891011121314151617181920212223242526public class RunByRunnable implements Runnable&#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; public static void main(String[] args) &#123; RunByRunnable runByRunnable = new RunByRunnable(); Thread thread1 = new Thread(runByRunnable,"run1"); Thread thread2 = new Thread(runByRunnable,"run2"); Thread thread3 = new Thread(runByRunnable,"run3"); Thread thread4 = new Thread(runByRunnable,"run4"); thread1.setPriority(5); thread2.setPriority(3); thread3.setPriority(8); thread4.setPriority(1); thread1.start(); thread2.start(); thread3.start(); thread4.start(); &#125;&#125; (敲黑板！！)在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚⾄会忽略对线程优先级的设定。so: ==线程优先级不能作为程序正确性的依赖== 线程的状态java线程中一共有6种状态： new 新创建状态，还未调用start()方法 runnable 运行状态，java中，将就绪和运行统称“运行中” blocked 阻塞状态，线程阻塞于锁 waiting 等待状态，一直等待通知或中断 time_waiting 超时等待，等待通知或中断，超时后自动返回 terminated 当前线程已经执行完毕 Daemon线程​ Daemon线程即为守护线程，是一种支持性线程，主要用于程序后台中支持性工作。例如垃圾回收。当一个Java虚拟机不存在非Daemon的时候，Java虚拟机会自动退出，不论Daemon是否执行完毕，是什么状态。 ​ 方法： thread.setDaemon(true); 以下代码，可测试Daemon的运行是否会被强制杀掉 123456789101112131415161718192021222324public class DaemonThread extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println("DaemonThread running start"); TimeUnit.SECONDS.sleep(1); System.out.println("DaemonThread running end"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); System.out.println("DaemonThread InterruptedException"); &#125; catch (Exception e) &#123; e.printStackTrace(); System.out.println("DaemonThread exception"); &#125; finally &#123; System.out.println("DaemonThread finally"); &#125; &#125; public static void main(String[] args) &#123; DaemonThread daemonThread = new DaemonThread(); daemonThread.setDaemon(true); daemonThread.start(); &#125;&#125; 执行结果： DaemonThread running start 该程序有两个线程，一个主线程，一个被设置为Daemon的线程。守护线程开始执行后，进入睡眠状态。然后主线程执行完毕，这时JVM发现没有了非守护线程，于是直接退出了。Daemon线程中未执行完的代码，也不会再执行。 线程中断的概念和使用​ 中断可以理解为线程的一个标识位状态。它表示一个运行中的线程是否被其它线程进行了中断操作。 ​ 使用： A线程对B线程要进行中断： 在A中调用，B.interrupt()； B线程对A线程进行响应：通过调用方法 isInterrupted()方法判断是否被打断，true为中断过，false为未中断过。 标识位复位：Thread.interrupted ​ 当线程为终结状态，即使线程被中断过，标志位也为false当抛出InterruptedException异常时，jvm会先将中断标志位清除，所以isInterrupted() 为false。 实例代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ThreadInterrupt &#123; public static void main(String[] args) &#123; //sleepThread不停的尝试睡眠 Thread sleepThread = new Thread(new SleepRunner(), "sleepThread"); sleepThread.setDaemon(true); //budyThread线程一直在执行 Thread busyThread = new Thread(new BusyRunner(), "busyThread"); busyThread.setDaemon(true); sleepThread.start(); busyThread.start(); //休眠几秒钟，让两个线程充分运行 try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; sleepThread.interrupt(); busyThread.interrupt(); System.out.println("sleepThread interrupted is " + sleepThread.isInterrupted()); System.out.println("busyThread interrupted is " + busyThread.isInterrupted()); //防止两个线程提前退出 try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class SleepRunner implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class BusyRunner implements Runnable &#123; @Override public void run() &#123; while (true) &#123; //xxx 爱执行什么执行什么吧 &#125; &#125;&#125; 执行结果 sleepThread interrupted is falsebusyThread interrupted is truejava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at ThreadPackage.SleepRunner.run(ThreadInterrupt.java:57) at java.lang.Thread.run(Thread.java:748) 抛出InterruptedException的线程，中断位被清除了，另外一个线程，就没有被清除 总结本篇文章主要讲解Java线程的基础，使用。重点在于Java线程的创建和开启。 全部代码见： ​ https://github.com/ValjeanShaw/MyConcurrent/tree/develop/src/main/java/ThreadPackage]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[synchronized关键字]]></title>
    <url>%2F2018%2F07%2F16%2Fsynchronized%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[[TOC] 定义synchronized方法是java中常用的关键字，属于JVM层面，java的内置锁,Java中的每一个对象都可以作为锁，当对象被synchronized锁住之后，此对象当前是被该锁和该线程独占。 应用分为修饰方法和修饰代码块两大类：具体如下 4种用法： 修饰实例方法 修饰静态方法 同步实例方法中的代码块 同步静态方法中的代码块 修饰实例方法123456789public synchronized void addOne()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; num++; System.out.println(this.getId()+" "+num+" "+System.currentTimeMillis()); &#125; 当修饰实例方法时，锁住的是调用该方法的当前对象，即：12Thread thread1 = new ThreadTest();Thread thread2 = new ThreadTest(); thread1和thread2在同一时刻调用是不会产生冲突的，但是thread1和thread2自身内部是会相互竞争的。例，多个线程不能同时调用thread1.addOne()方法。 修饰静态方法123456789public static synchronized void addTwo()&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; count += 2; System.out.println(" "+count+" "+System.currentTimeMillis()); &#125; 锁住的是当前这个类的Class对象，即：当调动 addTwo()方法时，将产生竞争。不论实例对象是什么 修饰实例方法中的代码块1234567891011121314public void addThree()&#123; //使用了“this”，即为调用add方法的实例本身。 synchronized (this)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; number += 3; &#125; System.out.println(" "+number+" "+System.currentTimeMillis()); &#125; 重点关注synchronized (this)括号里面。this指定是引用的当前对象，效果和修饰实例方法一致。当()里面是 当前类的class对象时SynchronizedTest.class，效果和修饰静态方法一致。 修饰静态方法中的代码块123456789101112public static void addFour()&#123; synchronized (SynchronizedTest.class)&#123; try&#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; counter += 4; &#125; System.out.println(" "+counter+" "+System.currentTimeMillis()); &#125; 当静态方法时，()里面只能是当前类的class对象 SynchronizedTest.class，效果和修饰静态方法一致。 synchronized使用的两个细节问题 synchronized锁是可重入锁 父子类方法的锁可以重入 同一个对象的两个方法，也可以重入 123456789101112131415161718192021222324252627282930313233343536373839public class ReentrantSynchronized extends Father &#123; /** * sychronized 重写父类的方法，锁也可以重入 */ @Override public synchronized void doSomeThing() &#123; super.doSomeThing(); System.out.println(this.getClass() + " -- " + Thread.currentThread().getId() + " -- " + Thread.currentThread().getName()); System.out.println("ReentrantSynchronized child doSomeThing"); &#125; /** * sychronized 同一个对象中的两个方法，也可以重入 */ public synchronized void doOneThing() &#123; System.out.println(this.getClass() + " -- " + Thread.currentThread().getId() + " -- " + Thread.currentThread().getName()); System.out.println("ReentrantSynchronized child doOneThing"); doAnotherThing(); &#125; public synchronized void doAnotherThing() &#123; System.out.println(this.getClass() + " -- " + Thread.currentThread().getId() + " -- " + Thread.currentThread().getName()); System.out.println("ReentrantSynchronized child doAnotherThing"); &#125; public static void main(String[] args) &#123; ReentrantSynchronized reentrantSynchronized = new ReentrantSynchronized(); reentrantSynchronized.doSomeThing(); reentrantSynchronized.doOneThing(); &#125;&#125;class Father &#123; public synchronized void doSomeThing() &#123; System.out.println(this.getClass() + " -- " + Thread.currentThread().getId() + " -- " + Thread.currentThread().getName()); System.out.println("father doSomeThing()"); &#125;&#125; synchronized锁是自动锁，当抛出异常时，会自动释放锁 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 当异常被即时处理掉，未抛出synchronized的修饰区，不会释放锁 */ public synchronized void doOneThing() &#123; int i = 0; while (true) &#123; i++; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("now,the i is:" + i); try &#123; if (i == 10) &#123; //故意让它抛出异常 Integer.parseInt("a"); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); continue; &#125; &#125; &#125; /** * 异常抛出synchronized的修饰区，会释放锁 */ public synchronized void doTwoThing() &#123; int j = -100; while (true) &#123; j--; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println("yes boy,the j is:" + j); if (j == -110) &#123; //故意让它抛出异常 Integer.parseInt("a"); &#125; &#125; &#125; 附录，完整代码​ 传送带，请点击上车]]></content>
      <categories>
        <category>java</category>
        <category>并发</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[乐观锁和悲观锁]]></title>
    <url>%2F2018%2F07%2F12%2F%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[这两个属于常在数据库事务中被提及，乐观锁和悲观锁属于思想级别，是为了保持事务的隔离性以及数据库的一致性而被业内定义出来的一种手段,并不属于数据库锁机制,但是悲观锁是依赖于数据库的锁机制实现的。乐观锁不是数据库自带的，需要自己去实现。 [TOC] 定义 乐观锁：当前事务操作数据时，认为其他事务不会修改正在读取的数据具体： 事务读取 ，不上锁 事务更新，在提交数据更新之前，先检查在该事务读取数据后（更新前），有没有其他事务又修改了该数据。无，则事务提交；有，则事务失败。 悲观锁：认为事务在操作数据的时候，肯定会出现冲突数据库中悲观锁的实现分两种： 共享锁 （读锁，针对select的锁机制）读：多个事务可叠加锁，可以读数据，写数据将等待所有读锁都释放才能执行当对一个数据加入共享锁，其他事务对该数据最多只能再加共享锁，不能加排它锁 排它锁 （写锁，针对update,delete的锁机制）写：写数据时，独占该数据，该数据不能再加入任何其他锁，也不能叠加排它锁 怎么使用乐观锁和悲观锁是一种思想，在java中和数据库中均有不同的思路实现 java实现12* 乐观锁 java.util.concurrent.atomic包中的类，通过CAS算法实现* 悲观锁 sychronized方法 数据库实现1* 乐观锁 自行实现，可通过版本号或者时间戳实现 例子：下单操作 1. 查询当前信息，包括版本号 `select (status,status,version) from t_goods where id=#{id}` 2. 生成订单，业务操作 3. 更新数据 `update t_goods set status = #{status},version=version+1 where id=#{id} and version=#{version}` 123* 悲观锁 * 共享锁实现 sql语句： `lock in share mode` 例子：开启三个终端，非自动提交事务模式 一个终端开启共享锁 ​ 另一个终端对数据进行读，读成功，叠加共享锁也可以 第三个终端对数据进行update操作，写失败，一直等待 12* 排它锁实现 sql语句：`for update` 例子：开启两个终端 第一个执行排它锁，暂不提交事务 第二个终端执行两个操作select: 查询出未更改前的数据update:等待，如下图 当第一个终端提交事务 commit work,第二个终端的update操作执行完成 优缺点 乐观锁： 优点：适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。 缺点，冲突比较多的情况，执行会存在大量的失败，上层应用会不断的retry，这样反倒是降低了性能 悲观锁： 优点：保证了数据的完整性 缺点： 处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。]]></content>
      <categories>
        <category>锁</category>
      </categories>
      <tags>
        <tag>锁</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试真题]]></title>
    <url>%2F2018%2F07%2F10%2F%E9%9D%A2%E8%AF%95%E7%9C%9F%E9%A2%98%2F</url>
    <content type="text"><![CDATA[考拉阅读笔试题 基础部分，数组的传递是传递对象还是复制对象 补码计算方式 synchronized方法可修饰的是什么，修饰时候的作用是什么 写线程 面试题 hashmap和cocurrentHashMap的区别和联系 volatile方法的作用和内部分析 redis分布式锁 数据库中的锁 cas 还需准备的地方 redis的数据类型 并发 rabbitmq的复习 kafka的概念 spring boot redis 猫眼电影​ 先看简历，根据简历发问 画一画项目的系统架构图，使用的技术栈 mycat底层怎么管理主从，怎么管理读写分离 设计一个发报器的方案，用来生成id，不重复 ***（随意设计方案，分布式环境下） rabbitmq和kafka的选型（技术方案对比），底层的原理是否了解 dubbo,RPC的调用方式和HTTP调用方式的区别 java基础 hashmap的结构是什么样的，线程安全吗 hashMap中的红黑树，时间复杂度是多少，是否有安全的集合 concurrentHashMap的结构是什么样子的 为什么concurrentHashMap是安全的 volatile方法的作用是什么 volatile底层原理是什么，怎么实现的 java的内存屏障对volatile的影响 lock和sychronized是否了解，简述下区别 线程池是否了解，线程池在创建的时候，必传的参数是哪些 写一段代码，二分查找，时间复杂度多少 快看漫画 log日志是否会影响性能 rabbitmq和kafka选型区别 rabbitmq数据存储的地方 算法：将一个有序的短数组，插入到有序的长数组中，要求保证长数组有序 瓜子二手车 项目结构图 kafka和rabbitmq选型 技术对比 项目数据库怎么使用的 数据库事务机制分类 幻读和脏读 数据库索引分类 数据库主从通过什么实现的 索引分类 spring 和spring boot的关系 spring IOC怎么理解 IOC的注入方式分类 spring AOP怎么理解 aop通知的分类 环绕切点的使用 hashmap和hashtable的区别 concurrentHashMap volalite的作用 排序的map有哪些 sychronized锁对象 jvm的gc 线程池的种类 线程池的必要参数 遇到过最多的异常，异常的一些类 查找算法有哪些 二分查找的时间复杂度 排序算法有哪些 冒泡排序的时间复杂度 快排的时间复杂度 写一个算法：有一个数组，存在三种情况：1.递增 2.递减 3.先减后增（只有一个波谷）,写算法找出最小的值 花生好车 排序算法有哪些 设计不重复的分布式数据库id生成方案，按照一致性hash的思路怎么做 优化的思路，关于索引命中检查如何检查（索引的知识） 关于日志，是否真的有必要 数据库索引的B+树结构是否了解。in的操作是否会使用B+树 rabbitmq是否是有序的，有没有回应机制 rabbitmq的patition是否知道 redis的数据结构有几种 有一个对象，里面含有一些元素，怎么存入redis中（比较频繁操作，要求性能） redis的分布式集群怎么做 redis的持久化怎么实现 spring IOC容器注入原理，源码是否看过 java基础。集合的分类，collection下面有什么集合，map集合是不是在一起 map的初始容量和负载因子是多少 扩容怎么扩容，具体流程，是否是一个一个复制 concurrent包下面比较熟悉哪个知识点（volatile）,作用和原理是什么，应用场景是什么 队列同步器，是否熟悉，有哪些队列同步器 jvm中，堆和栈怎么定义，怎么使用 用java写一个链表的简单操作，插入一个元素和删除一个元素。 借贷宝 项目结构图 数据库索引，数据库索引命中怎么看（explain） 数据库索引怎么创建 数据库索引原理 数据库索引唯一索引怎么定义 身份证为例子 数据库联合索引 abc a ab abc 实现原理 sql语句调优怎么调优 乐观锁和悲观锁怎么定义，优缺点是什么 集合有哪些（学一下怎么描述） list和set的区别是什么 有一个list,里面有20个user,要求按照age存储，怎么存储 数据库中存储，按照class和sex统计总人数 group by git的工作区，暂存区和远程仓库 有两段代码重复，按照阿里规约怎么写 二叉树，层序遍历写出 引申： 数据库索引和原理一定要搞清楚（弱项） 二叉树几个遍历 java集合再总结一遍 突出亮点，让人感觉有特点]]></content>
  </entry>
</search>
